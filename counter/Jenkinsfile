// Defines the entire CI/CD process as a Declarative Pipeline.
pipeline {
    // Specifies that the pipeline can run on any available Jenkins agent.
    agent any

    // Defines parameters that can be set by the user when triggering the pipeline.
    // This makes the pipeline flexible without needing to change the code.
    parameters {
        string(name: 'GITHUB_REPO', defaultValue: 'https://github.com/devatefops/counter-app.git', description: 'GitHub repository URL')
        string(name: 'BRANCH', defaultValue: 'master', description: 'Branch to clone')
        string(name: 'TARGET_HOST', defaultValue: '13.63.34.25', description: 'App server IP') // optional for deploy later
    }

    // Sets environment variables that are available throughout the pipeline.
    environment {
        DEPLOY_USER = "deploy"       // The user on the app server
        WORKSPACE_DIR = "workspace"  // Optional workspace subdirectory
        // Define your Docker registry and image name
        DOCKER_REGISTRY = "docker.io/devatefops" // e.g., docker.io/your-username
        IMAGE_NAME = "counter-app"
    }

    // Contains the sequential stages that make up the workflow.
    stages {

        stage("Checkout") {
            steps {
                echo "Cloning repo ${params.GITHUB_REPO} on host ${params.TARGET_HOST}"
                // Use the sshagent wrapper to securely provide SSH credentials for the connection.
                // 'server-app-ssh' is the ID of the credential stored in Jenkins.
                sshagent(credentials: ['server-app-ssh']) {
                    sh """
                        # Connect to the remote host and execute a script.
                        ssh -o StrictHostKeyChecking=no ${DEPLOY_USER}@${params.TARGET_HOST} \
                        "rm -rf ${WORKSPACE_DIR}/counter-app && git clone --branch ${params.BRANCH} ${params.GITHUB_REPO} ${WORKSPACE_DIR}/counter-app"
                    """
                }
            }
        }

        stage('Run Tests') {
            steps {
                // This is a placeholder for your test commands.
                // For a Go project, this would typically be 'go test ./...'.
                echo "Running tests... (placeholder)"
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    // Define the full image tag using the build number for versioning.
                    def fullImageName = "${DOCKER_REGISTRY}/${IMAGE_NAME}:${BUILD_NUMBER}"
                    echo "Building Docker image: ${fullImageName}"
                    // Build the image on the Jenkins agent.
                    docker.build(fullImageName, '.')
                }
            }
        }

        stage('Push Docker Image') {
            steps {
                script {
                    def fullImageName = "${DOCKER_REGISTRY}/${IMAGE_NAME}:${BUILD_NUMBER}"
                    // Use a 'withDockerRegistry' block to handle authentication securely.
                    // 'docker-registry-credentials' is the ID of your registry credentials in Jenkins.
                    withDockerRegistry(credentialsId: 'docker-registry-credentials', toolName: 'docker') {
                        echo "Pushing Docker image to registry..."
                        // Push the image to your configured registry.
                        docker.image(fullImageName).push()
                    }
                }
            }
        }

        stage('Deploy') {
            steps {
                echo "Deploying container to ${params.TARGET_HOST}"
                // Use sshagent to securely connect to the target deployment server.
                sshagent(credentials: ['server-app-ssh']) {
                    sh """
                        ssh -o StrictHostKeyChecking=no ${DEPLOY_USER}@${params.TARGET_HOST} /bin/bash -s <<'EOF'
                            # Define the image to be pulled from the registry.
                            IMAGE_TO_PULL="${DOCKER_REGISTRY}/${IMAGE_NAME}:${BUILD_NUMBER}"

                            echo "Pulling latest image: \${IMAGE_TO_PULL}"
                            docker pull \${IMAGE_TO_PULL}

                            echo "Stopping and removing existing container..."
                            docker stop ${IMAGE_NAME}-container || true
                            docker rm ${IMAGE_NAME}-container || true

                            echo "Running new container..."
                            docker run -d --name ${IMAGE_NAME}-container -p 8080:8080 \${IMAGE_TO_PULL}
EOF
                    """
                }
            }
        }
    }

    // The post block defines actions that run at the end of the pipeline's execution.
    post {
        success {
            echo "Pipeline completed successfully!"
        }
        failure {
            echo "Pipeline failed. Check console log for details."
        }
    }
}
